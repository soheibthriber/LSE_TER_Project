/*

this code source is wrriten in the context of an academic project in the master LSE (ubo 2018)
the aim of this project is to test a numbre of real time scheduling properties by analysing a trace generated by a real time systeme running on a FPGA. 

this trace is provided in an xml format, and it's devided into 2 files : 
the first provides the information of the real time system( nmb of proc/core, nmb and properties of the periodique tasks, and idem for the shared ressources. 
and the second represent the actual trace with the different types of events that occured on the system.

Our code contains 3 source file : 

-----> systeme.h and systeme.c : where the ADT (Abstract Data Type) is defined ( struct and functions). 

-----> sys_parser.c : the main sourcefile that parse the xml files of any given examples and analyse the RT properties.

the over all scheme of the process goes like this: 

§ 1-  we first begin by parsing the xml file that represent the RT system and create a temporary array of stucures (tasks and ressources prop).

§ 2- then we use those arrays and the constructure functions of the ADT to allocate space and initialise our instance of the systeme ADT) . after that we free the tmp structures 
     
§ 3- then we proceed to the parsing of the xml file (the actual trace) and create another temporary array of a structutre event ( describe all the occuring events) 

% 4- finnaly we cross this array element by element and excute the analyse algorithme .     
  
*/


#include <libxml/parser.h>
#include <libxml/tree.h>
#include<stdio.h>
#include<string.h>
#include "systeme.h"


// structure pour représenter une tache Id: identifiant ex: 'id_31'   
typedef struct task_r {

char Id[5] ; int Capacity ;int Period; int Deadline; int Start_time; int  Priority;    
}task_r;


/* structure pour représenter un évenement de la trace: avec Op est l'Operation ('A' pour task_activation , 'S' pour start_task_capacity ,'R' pour Running_task, 'E' pour End_of_task_capacity) ,  le temps de l'évenement  la tache selétionné par l'évenement*/

typedef struct event_s{
char Op;     
int time_unit; 
char task_selected[5] ;   
}event;


//un tableau de taches pour enregistrer temporairement les taches avec task_position est la position de la tache dans le tableau des taches 
int task_position=-1;  
task_r * tmp=NULL;    

xmlDoc*  doc  = NULL;  

systeme * exo1;   

char core_id[5];  // l'identifiant récuperé à partire du trace 
char tmp_task_id[5]; //  enregistrer temporairement les identifiants des taches    
int nmbT=0;   // nombre de taches total
int tmp_capacity=0,tmp_period=0,tmp_deadline=0,tmp_start_time=0,tmp_priority=0;

int nmbEvents=0,tmp_time_unit; //  nombre d'evenement
char tmp_Op,tmp_task_selected[5];

event * event_tab= NULL;  //enregistrer les evenement dans un tbleau de structure event 


// extraire les information sur les taches à partir de trace 
void get_tasks( xmlNode* root){

xmlChar *key;
	xmlNode* current = NULL;

	for ( current=root; current!=NULL; current=current->next )
		{
		
			if ( strcmp((char*)current->name,"periodic_task")==0 )	 
				{
				task_position++;nmbT++;
				strcpy(tmp_task_id,(const char*)xmlGetProp( current, (const xmlChar*)"id") );	
				}		

			if ( strcmp((char*)current->name,"capacity")==0 )
				{
				key = xmlNodeListGetString(doc, current->xmlChildrenNode, 1);
				tmp_capacity=atoi(key);				
				xmlFree(key);
				}
			if ( strcmp((char*)current->name,"deadline")==0 )
				{
				key = xmlNodeListGetString(doc, current->xmlChildrenNode, 1);
				tmp_deadline=atoi(key);
				xmlFree(key);
				}
			if ( strcmp((char*)current->name,"period")==0 )
				{
				key = xmlNodeListGetString(doc, current->xmlChildrenNode, 1);
				tmp_period=atoi(key);
				xmlFree(key);
				}
			if ( strcmp((char*)current->name,"start_time")==0 )
				{
				key = xmlNodeListGetString(doc, current->xmlChildrenNode, 1);
				tmp_start_time=atoi(key);				
				xmlFree(key);
				}
			if ( strcmp((char*)current->name,"priority")==0 )
				{
				key = xmlNodeListGetString(doc, current->xmlChildrenNode, 1);
				tmp_priority=atoi(key);				
				xmlFree(key);
				}
			if ( strcmp((char*)current->name,"every")==0 )
				{
 				tmp=(task_r*) realloc(tmp,nmbT*sizeof(task_r));
				strcpy(tmp[task_position].Id,tmp_task_id);
				tmp[task_position].Capacity=tmp_capacity;tmp[task_position].Deadline=tmp_deadline;
				tmp[task_position].Period=tmp_period;tmp[task_position].Start_time=tmp_start_time;
				tmp[task_position].Priority=tmp_priority;	
 				}		
		get_tasks(current->children); 
		}
}


// extraire les informations sur le core  
void get_content( xmlNode* root )
{
	xmlChar *key;
	xmlNode* current = NULL;

	for ( current=root; current!=NULL; current=current->next )
		{
  
		if ( strcmp((char*)current->name,"core_unit")==0 ) 
		{
		strcpy(core_id,(const char*)xmlGetProp( current, (const xmlChar*)"id") );
		} 
		
		if ( strcmp((char*)current->name,"tasks")==0 ) { get_tasks(current->children ); break;} 
		
		get_content( current->children );
		}
}


// extraire les evenements aprés le noeud <result> 
void get_events( xmlNode* root )
{
	xmlChar *key;
	xmlNode* current = NULL;

	for ( current=root; current!=NULL; current=current->next )
		{
		
		
			if ( strcmp((char*)current->name,"time_unit")==0 )	 
				{
				nmbEvents++;
				key = xmlNodeListGetString(doc, current->xmlChildrenNode, 1);
				tmp_time_unit=atoi(key);				
				xmlFree(key);
				}
			if ( strcmp((char*)current->name,"activation_task")==0 )	 
				{
				strcpy(tmp_task_selected,(const char*)xmlGetProp( current, (const xmlChar*)"ref" ) );	
				tmp_Op='A';
				event_tab= (event *) realloc(event_tab,nmbEvents*sizeof(event));
				strcpy(event_tab[nmbEvents-1].task_selected,tmp_task_selected);
				event_tab[nmbEvents-1].Op=tmp_Op;event_tab[nmbEvents-1].time_unit=tmp_time_unit;
				}			
				
				if ( strcmp((char*)current->name,"start_task")==0 )	 
				{
				strcpy(tmp_task_selected,(const char*)xmlGetProp( current, (const xmlChar*)"ref" ) );	
				tmp_Op='S';
				event_tab= (event *) realloc(event_tab,nmbEvents*sizeof(event));
				strcpy(event_tab[nmbEvents-1].task_selected,tmp_task_selected);
				event_tab[nmbEvents-1].Op=tmp_Op;event_tab[nmbEvents-1].time_unit=tmp_time_unit;
				}			
				if ( strcmp((char*)current->name,"running_task")==0 )	 
				{
				strcpy(tmp_task_selected,(const char*)xmlGetProp( current, (const xmlChar*)"ref" ) );	
				tmp_Op='R';
				event_tab= (event *) realloc(event_tab,nmbEvents*sizeof(event));
				strcpy(event_tab[nmbEvents-1].task_selected,tmp_task_selected);
				event_tab[nmbEvents-1].Op=tmp_Op;event_tab[nmbEvents-1].time_unit=tmp_time_unit;
				}
				if ( strcmp((char*)current->name,"end_task")==0 )	 
				{
				strcpy(tmp_task_selected,(const char*)xmlGetProp( current, (const xmlChar*)"ref" ) );	
				tmp_Op='E';
				event_tab= (event *) realloc(event_tab,nmbEvents*sizeof(event));
				strcpy(event_tab[nmbEvents-1].task_selected,tmp_task_selected);
				event_tab[nmbEvents-1].Op=tmp_Op;event_tab[nmbEvents-1].time_unit=tmp_time_unit;
				}		

		get_events( current->children );
		}
}



void get_trace( xmlNode* root )
{
	xmlChar *key;
	xmlNode* current = NULL;

	for ( current=root; current!=NULL; current=current->next )
		{
		
		if ( strcmp((char*)current->name,"result")==0 ) { get_events(current->children ); break;} 

		get_trace( current->children );
		}
}




int main()
{
	int i,task_position;
// ************************************************************parser le fichier qui décrit le systéme 
	doc = xmlReadFile( "exo2_2tuto.xml", NULL, 0 );
	xmlNode* root = NULL;


	if ( doc==NULL ) return 0;
   
	root = xmlDocGetRootElement( doc );
	get_content( root );
	xmlFreeDoc( doc );
	xmlCleanupParser();
   
	char tasks_map[nmbT][5]; // on va mapper les identifiant des taches avec un tableau
	
// **************************************************************declaration et initialisation des taches 
	exo1 = Create_system(core_id,nmbT);
	for( i=0; i<nmbT; i++)
		{
		strcpy(tasks_map[i],tmp[i].Id );   	
		init_task(exo1,tmp[i].Id,tmp[i].Capacity,tmp[i].Period,tmp[i].Deadline,tmp[i].Start_time,i);
		}

	

//*******************************************************************parser la trace  	
	doc = xmlReadFile( "trace_exo2_2tuto.xml", NULL, 0 );
	root = NULL;
	if ( doc==NULL ) return 0;
	root = xmlDocGetRootElement( doc );
	get_trace(root);	
	xmlFreeDoc( doc );
	xmlCleanupParser();



//******************************************************************analyse de la trace 
for (i=0;i<nmbEvents;i++)
	{
	int j;

// mapper les identifiant à leur position
	for(j=0;j<nmbT;j++)	{	if (strcmp(event_tab[i].task_selected,tasks_map[j])==0)	task_position=j;}



// ******************************************************************les fonctions de verification
	for(j=0;j < exo1-> numberOfTasks;j++){ 
		if ( (exo1 -> current_time_unit % exo1 -> tasks[j].Period == exo1 -> tasks[j].Period - 1) && (! exo1 -> tasks[j].checked) )
		{
		if(Check_activation(exo1,j)) printf ("?!?!?!?!?no activation alert task %s ?!?!?!?!?\n",tasks_map[j]);
	        if(Check_deadline(exo1,j)) //printf ("?!?!?!?!?deadline alert task %s !?!?!?!?!?!?!?!?\n",tasks_map[j]);
		Reinit_task ( exo1, j);			
		}
		
		   
	}
	
//*********************************************************************fonctions de changement d'etat  	
	for(j=0;j < exo1-> numberOfTasks;j++){ 	
	if ( exo1 -> current_time_unit % exo1 -> tasks[j].Period == 0 ) {exo1 -> tasks[j].checked=false;/* printf("task %s checked state %d\n",tasks_map[j],exo1 -> tasks[j].checked);*/}
		}


      
	switch(event_tab[i].Op) {
		case 'A':
			Task_activation(exo1,event_tab[i].time_unit,task_position);
		break;


		case 'S':
			Start_of_task_capacity(exo1,event_tab[i].time_unit, task_position);
		break;


		case 'R':
			Task_running(exo1,event_tab[i].time_unit,task_position); 
		//printf("time consummed %d **** activation_time %d \n",exo1 -> tasks[task_position].time_consumed,exo1 -> tasks[task_position].Activation_time);  
		break;

		case 'E':
			End_of_task_capacity(exo1,event_tab[i].time_unit,task_position);
		break;

		default:
			printf("no valid operation\n");
		break;
		}	
	}		
return 1;
}
